#include<iostream>  //заголовок std::cout << lllll << std::endl;
#include<locale.h> // заголовочгый файл для функции setlocale()
#include<iomanip> // заголовочный файл для cout, « и много чего еще
#include<bitset>

//Тема 1. ОПЕРАТОРЫ C/C++ СТРОЕНИЕ МИНИМАЛЬНОЙ ПРОГРАММЫ C/C++

#pragma region MainFunc
//во-первых - функция, во-вторых точка входа 
//во всей программе должна быть одна функция main();

int main()  
{//блоки кода в функциях, операторах, и просто блоки отдельно взято
	//классификация операторов 

	/* классификация операторов
	* 1. арифметические (+, -, *, /, % - остаток от целого деления
	++ - увеличить на единицу, или "инекремент"
	— - уменьшить на единицу, или "декримент")
	* 2. логические или булевы (|| - оператор "или", оператор "и" ! оператор отрицания)
	* 3. побитовые ("&" - бинарное "и" , "|" - бинарное "или" оператор сдвига с влево "<<" оператор сдвига с право ">>" тильда " ")
	* 4. операторы сравнения (">" - больше, "<" - меньше, "==" - равно,
	                          ">=" - больше или равно, "<=" - меньше или равно)
	*/
	//2 бинарные ,унарные и один тернарный	
		//Унарные - работуюшие с единственным операндом ("!","~","++","--" и тд)
		// Бинарные работуюшие с двумя операндами (+, -, *, /, % , >> ,<<, &&,||, |,^  и тд)
		//тернарный работуюшие с тримя операндами (лог__усло ветка_если_true_ecли_false)
		// операнд - данные с которым применятся оператор.

	setlocale(LC_ALL, "Russian");
	int a = 10;
	int b = 3;
	std::cout << "Тема 1. ОПЕРАТОРЫ C/C++ СТРОЕНИЕ МИНИМАЛЬНОЙ ПРОГРАММЫ C/C++" << std::endl;
	int result = 10 % 3;
	std::cout << "a = 10, b = 3" << std::endl;
	std::cout << "10 % 3 =" << 10 % 3 << "\n"; // "\n" тоже самое  
	bool c = true;
	bool d = false;
	bool e = true;

	// \t, \n - escape последовательности\управляющие символы - они кодируют вывод символов которые нельзя набрать с клавиатуры
	// \t - один символ табуляции ( при компиляции компилятор заменяет пару символо \t на один символ табуляции)
	// \n - один символ переноса строки ( при компиляции компилятор заменяет пару символо \t на один символ строки)
	// служебным символом для начала escape последовательности является \
	// если нужно употреблить сам по себе слеш \ без escape - последовательности
	// то следует в строке в коде писать '\\'
	//обратный слеш / - это просто символ без особого значения
	
	std::cout << "\t\t a = true\t b= false" << std::endl;
	std::cout << "a = false" "\t\ " << (true && true)<< "\t\t " <<(true && false) << std::endl;
	std::cout << "a = false" "\t\ " << (false && true) << "\t\t " << (true && false) << std::endl;
	
	/// ДЗ
	int binary_int0x00 = 0b1010;
	int binary_int0x01 = 0b1100;


	std::cout << "\n \na = " << std::bitset<8>(a) << "; b =" << b
		<< ": a >> b = " << std::bitset<8>(a >> b) << std::endl;

	std::cout << "a = " << std::bitset<8>(a) << "; b =" << b
		<< ": a << b = " << std::bitset<8>(a >> b) << std::endl;

	std::cout << "a = " << std::bitset<8>(a) << "; ~a = " << b
		<< ": a = "<< (a) << std::bitset<8> (~a)<< std::endl;

	//bool e = true;
	//std::cout << "d = " << d << "!d = " << !d << std::endl


	// код для демонстации оператора >> 

	std::cout << "\n \n демонстации оператора >> " << (a >> b) << std::endl;

	// код для демонстации оператора  << 

	std::cout << "демонстации оператора << " << (a << b) << std::endl;

	// код для демонстации оператора  ~ 
	std::cout << "демонстации оператора ~ " << ( ~ a) << std::endl;



	std::cout << "\t \n \n(  |  )"<< std::endl;

	std::cout << "\n \n \n \n \tБинарное Число 1 = " << std::endl;
	std::cout << "\tБинарное Число 2 = " << std::bitset<4>(binary_int0x01) << std::endl;
	std::cout << "\t		   ----" << std::endl;
	std::cout << "\t	    Ответ> " << std::bitset<4>(binary_int0x00 | binary_int0x01) << std::endl;

	std::cout << "\t(  &  )" << std::endl;

	std::cout << "\n \n \n \n \tБинарное Число 1 = " << std::bitset<4>(binary_int0x00) << std::endl;
	std::cout << "\tБинарное Число 2 = " << std::bitset<4>(binary_int0x01) << std::endl;
	std::cout << "\t		   ----" << std::endl;
	std::cout << "\t	    Ответ> " << std::bitset<4>(binary_int0x00 & binary_int0x01) << std::endl;

	std::cout << "\t(  ^  )"<< std::endl;

	std::cout << "\n \n \n \n \tБинарное Число 1 = " << std::bitset<4>(binary_int0x00) << std::endl;
	std::cout << "\tБинарное Число 2 = " << std::bitset<4>(binary_int0x01) << std::endl;
	std::cout << "\t		   ----" << std::endl;
	std::cout << "\t	    Ответ> " << std::bitset<4>(binary_int0x00 ^ binary_int0x01) << std::endl;
	////std::cout << "binary_int =" << binary_int << std::endl; // endl посто перенос на следующую строку



	std::cout << "\n \n a = "<< a << std::endl;
	std::cout << "Оператор ++ после числа a++ " << a++ << std::endl;
	std::cout << "После примение инкремента a " << a << std::endl;


	std::cout << "\n \n a = " << a << std::endl;
	std::cout << "Оператор ++ перед ++a " << ++a << std::endl;
	std::cout << "После примение инкремента a " << a << std::endl;
	//если оператор ++ стоит после числа, то число сначала выводится на печать, затем увеличивается !
	//если оператор ++ перед после числа, то число сначала увеличивается, затем выводится !


	//2 ТИПЫ ДАННЫХ ЯЗЫКА С/С++
	//2.1 целочисленных типы используется для хранения целых чисел положительных отрицательных и беззнаковых.

	char char_var; //название любое | Занимает памяти 8 бит (байт) может хранить числа от -128 до 127
	short short_var; // занимает в памяти 16 бит ( 2 байта) хранит числа от 32 767 до -32 768
	int int_var; // занимает в памяти 32 бита ( 4 байта) хранит числа от INT32_MIN ДО INT32_MAX
	long long_car // аналогично что int
	//long int li_var; // аналогично long int 64бит (8 байт);; 
	int li2_var; //аналог long int
	
	//если приписать к любому целому знаоковму типу модификатор unsign, то
	// положительный диапазон (т.е максимально положительное число увеличивается в 2 раза
	// в число с меткой unsign нельзя будет записать отрицательные числа

	unsigned char char_var;// размер тот же ,что у типа char, но диапозон начинается с 0 до 255 
	unsigned short short_var; //аналогично
	unsigned int int_var;//аналогично
	unsigned long long_var;//аналогично
	unsigned long int li_var;//аналогично
	unsigned long long li_var;//аналогично

	// 2.2 Арифметичесик типы с плавфющей точке 
	float float_var; //имеет объем с 4 байта (32 бита) ОТ FLT_MIN ДО FLT_MAX
	double dbl_var;

	//2.3 Логические типы данных
	bool bool_var; //всего два значения true - false
	std::cout << "Длина типа bool в 64x sizeof = "
		<< sizeof(bool) << std::endl;

	//2.4 символьные типы данных
	char chr_var; //диапазона ариыметического типа char очень кстати хватает на кодирование таблицы символов
	//поэтому чаще тип char используется именно для хранения символов и строк чем для арифметики

	wchar_t wchr_var; //имеет объем 16 бит (2 байта) и введен для хранения символов юникода
	//или других расширенных кодировок

	//2.5 Универсалиный или пустой тип void 
	// уомпилятор рассматривает void проосто как ячейку с неопределенным данными
	//служебный тип данных может использоваться как заглушка если функция не возвращает и 
	//не принимает значений либо в сложных конструкциях


	std::system("pause"); // вызов функции system() из стандартной библиотеки 
	return 0;
}
#pragma endregion MainFunc

